"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _index = require("../store/index");
var _error_screen = _interopRequireDefault(require("../core/error_screen"));
var _loading_screen = _interopRequireDefault(require("../core/loading_screen"));
var _social_or_email_login_screen = _interopRequireDefault(require("./passwordless/social_or_email_login_screen"));
var _social_or_phone_number_login_screen = _interopRequireDefault(require("./passwordless/social_or_phone_number_login_screen"));
var _ask_vcode = _interopRequireDefault(require("../connection/passwordless/ask_vcode"));
var _last_login_screen = _interopRequireDefault(require("../core/sso/last_login_screen"));
var _index2 = require("../connection/passwordless/index");
var _sync = require("../sync");
var l = _interopRequireWildcard(require("../core/index"));
var _quick_auth = require("../quick_auth");
var sso = _interopRequireWildcard(require("../core/sso/index"));
var _email = require("../field/email");
var _phone_number = require("../field/phone_number");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var setPrefill = function setPrefill(m) {
  var _l$prefill$toJS = l.prefill(m).toJS(),
    email = _l$prefill$toJS.email,
    phoneNumber = _l$prefill$toJS.phoneNumber;
  if (typeof email === 'string') {
    m = (0, _email.setEmail)(m, email);
  }
  if (typeof phoneNumber === 'string') {
    m = (0, _phone_number.setPhoneNumber)(m, phoneNumber);
  }
  return m;
};
var Passwordless = /*#__PURE__*/function () {
  function Passwordless() {
    _classCallCheck(this, Passwordless);
  }
  _createClass(Passwordless, [{
    key: "didInitialize",
    value: function didInitialize(m, opts) {
      m = (0, _index2.initPasswordless)(m, opts);
      return m;
    }
  }, {
    key: "didReceiveClientSettings",
    value: function didReceiveClientSettings(m) {
      var anySocialConnection = l.hasSomeConnections(m, 'social');
      var anyPasswordlessConnection = l.hasSomeConnections(m, 'passwordless');
      if (!anySocialConnection && !anyPasswordlessConnection) {
        var error = new Error('At least one email, sms or social connection needs to be available.');
        error.code = 'no_connection';
        m = l.stop(m, error);
      }
      m = setPrefill(m);
      return m;
    }
  }, {
    key: "render",
    value: function render(m) {
      //if there's an error, we should show the error screen no matter what.
      if (l.hasStopped(m)) {
        return new _error_screen.default();
      }

      // TODO: remove the detail about the loading pane being pinned,
      // sticky screens should be handled at the box module.
      if (!(0, _sync.isDone)(m) || m.get('isLoadingPanePinned')) {
        return new _loading_screen.default();
      }
      if (!(0, _quick_auth.hasSkippedQuickAuth)(m)) {
        if (l.ui.rememberLastLogin(m)) {
          var lastUsedConnection = sso.lastUsedConnection(m);
          var lastUsedUsername = sso.lastUsedUsername(m);
          if (lastUsedConnection && (0, _sync.isSuccess)(m, 'sso') && l.hasConnection(m, lastUsedConnection.get('name')) && ['passwordless', 'social'].indexOf(l.findConnection(m, lastUsedConnection.get('name')).get('type')) >= 0 //if connection.type is either passwordless or social
          ) {
            var conn = l.findConnection(m, lastUsedConnection.get('name'));
            var connectionType = conn.get('type');
            if (connectionType === 'passwordless' || connectionType === 'social') {
              return new _last_login_screen.default();
            }
          }
        }
      }
      if ((0, _index2.isEmail)(m)) {
        return (0, _index2.isSendLink)(m) || !(0, _index2.passwordlessStarted)(m) ? new _social_or_email_login_screen.default() : new _ask_vcode.default();
      } else {
        return (0, _index2.passwordlessStarted)(m) ? new _ask_vcode.default() : new _social_or_phone_number_login_screen.default();
      }
    }
  }]);
  return Passwordless;
}();
var _default = new Passwordless();
exports.default = _default;
